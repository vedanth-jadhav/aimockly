# Data Models & Schema Codemap

**Last Updated:** 2026-01-22
**Freshness:** Current

## Database: Convex

Convex provides a serverless database with schema validation, real-time subscriptions, and ACID transactions.

## Schema Definition

Location: `convex/schema.ts`

## Entity Relationship Diagram

```
users (auth)
  ↓ 1:1
profiles
  ↓ 1:N
projects
  ↓ 1:N
scans
  ↓ 1:N
issues

payments ← N:1 → users
payments ← N:1 → projects (optional)
```

## Table Details

### `users` (Auto-generated by Convex Auth)
Authentication identity table.

**Fields:** (Internal to Convex Auth)
- `_id` - System ID
- `_creationTime` - Auto-timestamp
- Email/password hash/tokens (managed by auth system)

### `profiles`
Extended user profile information.

**Fields:**
| Field | Type | Required | Indexed | Description |
|-------|------|----------|---------|-------------|
| `_id` | ID | ✓ | ✓ | Primary key |
| `userId` | ID(users) | ✓ | ✓ | Foreign key to auth users |
| `name` | string | ✗ | ✗ | Display name |
| `email` | string | ✓ | ✓ | Email address |
| `avatarUrl` | string | ✗ | ✗ | Profile picture URL |
| `stripeCustomerId` | string | ✗ | ✓ | Stripe customer ID |
| `plan` | "free"\|"pro"\|"team" | ✓ | ✗ | Subscription tier |
| `projectsLimit` | number | ✓ | ✗ | Max projects allowed |
| `createdAt` | number | ✓ | ✗ | Unix timestamp |
| `updatedAt` | number | ✓ | ✗ | Unix timestamp |

**Indexes:**
- `by_userId(userId)` - Lookup by auth user
- `by_email(email)` - Lookup by email
- `by_stripeCustomerId(stripeCustomerId)` - Stripe integration

**Business Rules:**
- Free plan: `projectsLimit = 3`
- Pro plan: `projectsLimit = 25`
- Team plan: `projectsLimit = 100`

### `projects`
Supabase projects being scanned.

**Fields:**
| Field | Type | Required | Indexed | Description |
|-------|------|----------|---------|-------------|
| `_id` | ID | ✓ | ✓ | Primary key |
| `userId` | ID(users) | ✓ | ✓ | Owner |
| `name` | string | ✓ | ✗ | Project name |
| `supabaseUrl` | string | ✓ | ✓ | Target Supabase URL |
| `lastScannedAt` | number | ✗ | ✗ | Last scan timestamp |
| `totalScans` | number | ✓ | ✗ | Count of scans |
| `createdAt` | number | ✓ | ✗ | Unix timestamp |
| `updatedAt` | number | ✓ | ✗ | Unix timestamp |

**Indexes:**
- `by_userId(userId)` - User's projects
- `by_supabaseUrl(supabaseUrl)` - Prevent duplicates

**Security Note:** Anon keys are NOT stored (only used during scan, then discarded).

**Computed Fields:**
- `lastScan` - Joined from scans table
- `issueCount` - Aggregated from issues

### `scans`
Security scan executions.

**Fields:**
| Field | Type | Required | Indexed | Description |
|-------|------|----------|---------|-------------|
| `_id` | ID | ✓ | ✓ | Primary key |
| `projectId` | ID(projects) | ✓ | ✓ | Foreign key |
| `userId` | ID(users) | ✓ | ✓ | Owner |
| `status` | enum | ✓ | ✓ | Scan state |
| `healthScore` | number | ✗ | ✗ | 0-100 score |
| `issuesFound` | number | ✗ | ✗ | Count of issues |
| `tablesScanned` | number | ✗ | ✗ | Count of tables |
| `errorMessage` | string | ✗ | ✗ | Failure details |
| `startedAt` | number | ✓ | ✗ | Unix timestamp |
| `completedAt` | number | ✗ | ✗ | Unix timestamp |

**Status Enum:**
- `"pending"` - Created, not started
- `"scanning"` - In progress
- `"completed"` - Success
- `"failed"` - Error occurred

**Indexes:**
- `by_projectId(projectId)` - Project scan history
- `by_userId(userId)` - User's scans
- `by_status(status)` - Filter by status

**Lifecycle:**
1. Created with `status = "pending"`
2. Updated to `status = "scanning"` when API starts
3. Finished with `status = "completed"` or `"failed"`
4. `completedAt` set on completion

### `issues`
Security vulnerabilities detected in scans.

**Fields:**
| Field | Type | Required | Indexed | Description |
|-------|------|----------|---------|-------------|
| `_id` | ID | ✓ | ✓ | Primary key |
| `scanId` | ID(scans) | ✓ | ✓ | Foreign key |
| `projectId` | ID(projects) | ✓ | ✓ | Foreign key |
| `userId` | ID(users) | ✓ | ✓ | Owner |
| `type` | string | ✓ | ✗ | Issue category |
| `severity` | enum | ✓ | ✓ | Severity level |
| `tableName` | string | ✓ | ✗ | Affected table |
| `title` | string | ✓ | ✗ | Short description |
| `description` | string | ✓ | ✗ | User-friendly explanation |
| `technicalDetails` | string | ✗ | ✗ | Developer details |
| `suggestedFix` | string | ✗ | ✗ | Template SQL fix |
| `aiGeneratedFix` | string | ✗ | ✗ | AI-generated SQL |
| `aiAgentPrompt` | string | ✗ | ✗ | Prompt for AI assistants |
| `isResolved` | boolean | ✓ | ✗ | Resolution status |
| `resolvedAt` | number | ✗ | ✗ | Resolution timestamp |
| `createdAt` | number | ✓ | ✗ | Unix timestamp |

**Type Values:**
- `"rls_missing"` - No RLS enabled
- `"rls_permissive"` - Overly broad RLS
- `"public_table"` - Publicly accessible
- `"sensitive_data"` - Exposed PII/secrets

**Severity Enum:**
- `"critical"` - Immediate action required
- `"warning"` - Should be addressed
- `"info"` - Informational

**Indexes:**
- `by_scanId(scanId)` - Scan's issues
- `by_projectId(projectId)` - Project's all issues
- `by_userId(userId)` - User's all issues
- `by_severity(severity)` - Filter by severity

**AI Enhancement Flow:**
1. Created with `suggestedFix` from scanner
2. User requests AI fix → calls `/api/generate-fix`
3. AI returns fix → saved to `aiGeneratedFix` + `aiAgentPrompt`

### `payments`
Stripe payment records.

**Fields:**
| Field | Type | Required | Indexed | Description |
|-------|------|----------|---------|-------------|
| `_id` | ID | ✓ | ✓ | Primary key |
| `userId` | ID(users) | ✓ | ✓ | Payer |
| `projectId` | ID(projects) | ✗ | ✗ | Associated project |
| `stripePaymentIntentId` | string | ✓ | ✓ | Stripe PI ID |
| `stripeCustomerId` | string | ✗ | ✗ | Stripe customer |
| `amount` | number | ✓ | ✗ | Amount in cents |
| `currency` | string | ✓ | ✗ | Currency code |
| `status` | enum | ✓ | ✗ | Payment status |
| `plan` | enum | ✓ | ✗ | Plan purchased |
| `createdAt` | number | ✓ | ✗ | Unix timestamp |

**Status Enum:**
- `"pending"` - Payment initiated
- `"succeeded"` - Charged successfully
- `"failed"` - Payment failed
- `"refunded"` - Refund issued

**Plan Enum:** `"pro"` | `"team"` (no free plan payments)

**Indexes:**
- `by_userId(userId)` - User's payment history
- `by_stripePaymentIntentId(stripePaymentIntentId)` - Webhook lookup

## Scanner Data Structures

Location: `lib/scanner/rls-analyzer.ts`

### `SecurityIssue` (TypeScript Interface)
```typescript
{
  type: 'rls_missing' | 'rls_permissive' | 'public_table' | 'sensitive_data'
  severity: 'critical' | 'warning' | 'info'
  tableName: string
  title: string
  description: string
  technicalDetails?: string
  suggestedFix?: string
}
```

### `ScanResult` (TypeScript Interface)
```typescript
{
  healthScore: number        // 0-100
  tablesScanned: number
  issues: SecurityIssue[]
  tables: TableInfo[]
}
```

### `TableInfo` (TypeScript Interface)
```typescript
{
  name: string
  schema: string             // 'public'
  rlsEnabled: boolean
  columns: { name: string, type: string }[]
}
```

## AI Data Structures

Location: `lib/ai/fix-generator.ts`

### `FixGenerationRequest` (TypeScript Interface)
```typescript
{
  tableName: string
  issueType: string
  issueDescription: string
  columns?: string[]
  currentPolicy?: string
}
```

### `GeneratedFix` (TypeScript Interface)
```typescript
{
  explanation: string        // User-friendly 1-2 sentences
  sql: string               // Copy-paste ready SQL
  agentPrompt: string       // Markdown prompt for AI assistants
}
```

## Data Validation

Convex schema provides runtime validation:
- Type checking (string, number, boolean, ID)
- Required vs optional fields
- Enum validation (literals)
- Foreign key validation (ID references)

## Data Access Patterns

### Common Queries

**Get user's recent scans:**
```typescript
ctx.db.query("scans")
  .withIndex("by_userId", q => q.eq("userId", userId))
  .order("desc")
  .take(10)
```

**Get scan with issues:**
```typescript
const scan = await ctx.db.get(scanId)
const issues = await ctx.db.query("issues")
  .withIndex("by_scanId", q => q.eq("scanId", scanId))
  .collect()
```

**Get critical issues for project:**
```typescript
ctx.db.query("issues")
  .withIndex("by_projectId", q => q.eq("projectId", projectId))
  .filter(q => q.eq(q.field("severity"), "critical"))
```

## Migration Strategy

Convex handles schema migrations automatically:
1. Update `schema.ts`
2. Deploy with `convex deploy`
3. Existing data validated against new schema
4. Breaking changes require manual data migration

## Backup & Recovery

Convex provides:
- Automatic backups
- Point-in-time recovery
- Export to JSON via CLI

## Data Retention

**Current Policy:** No automatic deletion
**Future Consideration:**
- Delete scans older than 90 days (free tier)
- Archive old issues
- GDPR compliance (user deletion)
